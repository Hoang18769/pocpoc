"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(home)/layout",{

/***/ "(app-pages-browser)/./src/utils/socket.js":
/*!*****************************!*\
  !*** ./src/utils/socket.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStompClient: function() { return /* binding */ createStompClient; }\n/* harmony export */ });\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sockjs-client */ \"(app-pages-browser)/./node_modules/sockjs-client/lib/entry.js\");\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sockjs_client__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stomp_stompjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stomp/stompjs */ \"(app-pages-browser)/./node_modules/@stomp/stompjs/esm6/client.js\");\n/* harmony import */ var _axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./axios */ \"(app-pages-browser)/./src/utils/axios.js\");\n\n\n\n\nfunction createStompClient(onConnect) {\n    const client = new _stomp_stompjs__WEBPACK_IMPORTED_MODULE_2__.Client({\n        webSocketFactory: ()=>new (sockjs_client__WEBPACK_IMPORTED_MODULE_0___default())(\"http://localhost/ws\"),\n        connectHeaders: {\n            Authorization: \"Bearer \" + ((0,_axios__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)() || \"\")\n        },\n        debug: (str)=>console.log(\"[STOMP DEBUG]\", str),\n        reconnectDelay: 5000,\n        onConnect: (frame)=>{\n            console.log(\"✅ STOMP connected\", frame);\n            if (onConnect) onConnect(frame);\n        },\n        onDisconnect: ()=>console.warn(\"⚠️ STOMP disconnected\"),\n        onWebSocketClose: ()=>console.warn(\"⚠️ WebSocket closed\"),\n        onWebSocketError: (event)=>console.error(\"❌ WebSocket error:\", event),\n        onStompError: (frame)=>{\n            var _frame_headers_message, _frame_body;\n            console.error(\"❌ STOMP error:\", frame.headers[\"message\"] || frame.body);\n            // Nếu bị lỗi 403 hoặc lỗi xác thực, thử refresh token và reconnect\n            if (((_frame_headers_message = frame.headers[\"message\"]) === null || _frame_headers_message === void 0 ? void 0 : _frame_headers_message.includes(\"403\")) || ((_frame_body = frame.body) === null || _frame_body === void 0 ? void 0 : _frame_body.includes(\"403\"))) {\n                console.log(\"\\uD83D\\uDD04 Token invalid. Will try to refresh and reconnect...\");\n                reconnectWithNewToken();\n            }\n        },\n        beforeConnect: async ()=>{\n            // Sử dụng approach kết hợp event + force refresh\n            let token = (0,_axios__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)();\n            if (!token || !(0,_axios__WEBPACK_IMPORTED_MODULE_1__.isTokenValid)()) {\n                console.log(\"\\uD83D\\uDD04 Getting valid token...\");\n                token = await waitForValidTokenWithFallback();\n            }\n            client.connectHeaders = {\n                Authorization: \"Bearer \" + (token || \"\")\n            };\n        }\n    });\n    // Gửi tin nhắn\n    client.sendMessage = function(destination, message) {\n        let headers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        if (!client.connected) {\n            console.error(\"❌ Client not connected. Cannot send message.\");\n            return false;\n        }\n        try {\n            client.publish({\n                destination,\n                body: JSON.stringify(message),\n                headers: {\n                    \"content-type\": \"application/json\",\n                    ...headers\n                }\n            });\n            return true;\n        } catch (error) {\n            console.error(\"❌ Error sending message:\", error);\n            return false;\n        }\n    };\n    // Subscribe channel\n    client.subscribeToChannel = function(destination, callback) {\n        let headers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        if (!client.connected) {\n            console.error(\"❌ Client not connected. Cannot subscribe.\");\n            return null;\n        }\n        return client.subscribe(destination, callback, headers);\n    };\n    // Reconnect with refreshed token\n    async function reconnectWithNewToken() {\n        try {\n            const token = await waitForValidTokenWithFallback();\n            client.connectHeaders = {\n                Authorization: \"Bearer \" + token\n            };\n            client.deactivate().then(()=>{\n                client.activate(); // reconnect\n            });\n        } catch (err) {\n            console.error(\"❌ Failed to refresh token and reconnect:\", err);\n        }\n    }\n    return client;\n}\n// Buộc lấy token hợp lệ - sử dụng axios interceptor để refresh\nasync function forceGetValidToken() {\n    let maxRetries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    let retries = 0;\n    while(retries < maxRetries){\n        try {\n            const token = (0,_axios__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)();\n            // Nếu có token và còn hạn thì return\n            if (token && (0,_axios__WEBPACK_IMPORTED_MODULE_1__.isTokenValid)()) {\n                console.log(\"✅ Token is valid\");\n                return token;\n            }\n            // Nếu không có token hoặc hết hạn, buộc refresh bằng cách gọi API protected\n            console.log(\"\\uD83D\\uDD04 Triggering token refresh (attempt \".concat(retries + 1, \"/\").concat(maxRetries, \")\"));\n            // Gọi một API protected để trigger refresh token trong axios interceptor\n            try {\n                await _axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/v1/auth/validate\"); // hoặc endpoint nào đó yêu cầu auth\n            } catch (error) {\n                var _error_response;\n                // Nếu lỗi 401, axios interceptor sẽ tự động refresh token\n                if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n                    console.log(\"\\uD83D\\uDD04 Token refresh triggered by 401 response\");\n                }\n            }\n            // Kiểm tra lại token sau khi axios interceptor xử lý\n            const newToken = (0,_axios__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)();\n            if (newToken && (0,_axios__WEBPACK_IMPORTED_MODULE_1__.isTokenValid)()) {\n                console.log(\"✅ Token refreshed successfully\");\n                return newToken;\n            }\n            throw new Error(\"Failed to get valid token after refresh attempt\");\n        } catch (error) {\n            retries++;\n            console.error(\"❌ Token refresh attempt \".concat(retries, \" failed:\"), error);\n            if (retries >= maxRetries) {\n                console.error(\"❌ Max retries reached. Session may be expired.\");\n                throw new Error(\"Unable to get valid token after multiple attempts\");\n            }\n            // Wait before retry\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * retries));\n        }\n    }\n}\n// Alternative: Sử dụng Promise.race để kết hợp event-based và polling\nfunction waitForValidTokenWithFallback() {\n    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3000;\n    return Promise.race([\n        // Approach 1: Chờ event từ axios interceptor\n        new Promise((resolve, reject)=>{\n            const token = (0,_axios__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)();\n            if (token && (0,_axios__WEBPACK_IMPORTED_MODULE_1__.isTokenValid)()) {\n                return resolve(token);\n            }\n            const unsubscribe = (0,_axios__WEBPACK_IMPORTED_MODULE_1__.onTokenRefresh)((newToken)=>{\n                if (newToken && (0,_axios__WEBPACK_IMPORTED_MODULE_1__.isTokenValid)()) {\n                    unsubscribe();\n                    resolve(newToken);\n                }\n            });\n            // Cleanup nếu không có token event trong thời gian timeout\n            setTimeout(()=>{\n                unsubscribe();\n                reject(new Error(\"Token event timeout\"));\n            }, timeout);\n        }),\n        // Approach 2: Force refresh ngay lập tức\n        (async ()=>{\n            // Đợi một chút để event có cơ hội xảy ra trước\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n            return forceGetValidToken();\n        })()\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RjtBQUVBLHNFQUFzRTtBQUN0RSxTQUFTakI7UUFBOEIwQixVQUFBQSxpRUFBVTtJQUMvQyxPQUFPSCxRQUFRSSxJQUFJLENBQUM7UUFDbEIsNkNBQTZDO1FBQzdDLElBQUlKLFFBQVEsQ0FBQ0MsU0FBU0k7WUFDcEIsTUFBTTdCLFFBQVE1QixvREFBWUE7WUFDMUIsSUFBSTRCLFNBQVMzQixvREFBWUEsSUFBSTtnQkFDM0IsT0FBT29ELFFBQVF6QjtZQUNqQjtZQUVBLE1BQU04QixjQUFjeEQsc0RBQWNBLENBQUMsQ0FBQ2dEO2dCQUNsQyxJQUFJQSxZQUFZakQsb0RBQVlBLElBQUk7b0JBQzlCeUQ7b0JBQ0FMLFFBQVFIO2dCQUNWO1lBQ0Y7WUFFQSwyREFBMkQ7WUFDM0RJLFdBQVc7Z0JBQ1RJO2dCQUNBRCxPQUFPLElBQUlOLE1BQU07WUFDbkIsR0FBR0k7UUFDTDtRQUVBLHlDQUF5QztRQUN4QztZQUNDLCtDQUErQztZQUMvQyxNQUFNLElBQUlILFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFDakQsT0FBT1Q7UUFDVDtLQUNEO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3NvY2tldC5qcz85MDkzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTb2NrSlMgZnJvbSBcInNvY2tqcy1jbGllbnRcIjtcclxuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIkBzdG9tcC9zdG9tcGpzXCI7XHJcbmltcG9ydCB7IGdldEF1dGhUb2tlbiwgaXNUb2tlblZhbGlkLCBvblRva2VuUmVmcmVzaCB9IGZyb20gXCIuL2F4aW9zXCI7XHJcbmltcG9ydCBhcGkgZnJvbSBcIi4vYXhpb3NcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9tcENsaWVudChvbkNvbm5lY3QpIHtcclxuICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHtcclxuICAgIHdlYlNvY2tldEZhY3Rvcnk6ICgpID0+IG5ldyBTb2NrSlMoXCJodHRwOi8vbG9jYWxob3N0L3dzXCIpLFxyXG4gICAgY29ubmVjdEhlYWRlcnM6IHtcclxuICAgICAgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIgKyAoZ2V0QXV0aFRva2VuKCkgfHwgXCJcIiksXHJcbiAgICB9LFxyXG4gICAgZGVidWc6IChzdHIpID0+IGNvbnNvbGUubG9nKFwiW1NUT01QIERFQlVHXVwiLCBzdHIpLFxyXG4gICAgcmVjb25uZWN0RGVsYXk6IDUwMDAsIC8vIGF1dG8gcmVjb25uZWN0XHJcbiAgICBvbkNvbm5lY3Q6IChmcmFtZSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBTVE9NUCBjb25uZWN0ZWRcIiwgZnJhbWUpO1xyXG4gICAgICBpZiAob25Db25uZWN0KSBvbkNvbm5lY3QoZnJhbWUpO1xyXG4gICAgfSxcclxuICAgIG9uRGlzY29ubmVjdDogKCkgPT4gY29uc29sZS53YXJuKFwi4pqg77iPIFNUT01QIGRpc2Nvbm5lY3RlZFwiKSxcclxuICAgIG9uV2ViU29ja2V0Q2xvc2U6ICgpID0+IGNvbnNvbGUud2FybihcIuKaoO+4jyBXZWJTb2NrZXQgY2xvc2VkXCIpLFxyXG4gICAgb25XZWJTb2NrZXRFcnJvcjogKGV2ZW50KSA9PiBjb25zb2xlLmVycm9yKFwi4p2MIFdlYlNvY2tldCBlcnJvcjpcIiwgZXZlbnQpLFxyXG4gICAgb25TdG9tcEVycm9yOiAoZnJhbWUpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBTVE9NUCBlcnJvcjpcIiwgZnJhbWUuaGVhZGVyc1tcIm1lc3NhZ2VcIl0gfHwgZnJhbWUuYm9keSk7XHJcbiAgICAgIC8vIE7hur91IGLhu4sgbOG7l2kgNDAzIGhv4bq3YyBs4buXaSB4w6FjIHRo4buxYywgdGjhu60gcmVmcmVzaCB0b2tlbiB2w6AgcmVjb25uZWN0XHJcbiAgICAgIGlmIChmcmFtZS5oZWFkZXJzW1wibWVzc2FnZVwiXT8uaW5jbHVkZXMoXCI0MDNcIikgfHwgZnJhbWUuYm9keT8uaW5jbHVkZXMoXCI0MDNcIikpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgVG9rZW4gaW52YWxpZC4gV2lsbCB0cnkgdG8gcmVmcmVzaCBhbmQgcmVjb25uZWN0Li4uXCIpO1xyXG4gICAgICAgIHJlY29ubmVjdFdpdGhOZXdUb2tlbigpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlQ29ubmVjdDogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAvLyBT4butIGThu6VuZyBhcHByb2FjaCBr4bq/dCBo4bujcCBldmVudCArIGZvcmNlIHJlZnJlc2hcclxuICAgICAgbGV0IHRva2VuID0gZ2V0QXV0aFRva2VuKCk7XHJcbiAgICAgIGlmICghdG9rZW4gfHwgIWlzVG9rZW5WYWxpZCgpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIEdldHRpbmcgdmFsaWQgdG9rZW4uLi5cIik7XHJcbiAgICAgICAgdG9rZW4gPSBhd2FpdCB3YWl0Rm9yVmFsaWRUb2tlbldpdGhGYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICAgIGNsaWVudC5jb25uZWN0SGVhZGVycyA9IHtcclxuICAgICAgICBBdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIiArICh0b2tlbiB8fCBcIlwiKSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIEfhu61pIHRpbiBuaOG6r25cclxuICBjbGllbnQuc2VuZE1lc3NhZ2UgPSAoZGVzdGluYXRpb24sIG1lc3NhZ2UsIGhlYWRlcnMgPSB7fSkgPT4ge1xyXG4gICAgaWYgKCFjbGllbnQuY29ubmVjdGVkKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgQ2xpZW50IG5vdCBjb25uZWN0ZWQuIENhbm5vdCBzZW5kIG1lc3NhZ2UuXCIpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjbGllbnQucHVibGlzaCh7XHJcbiAgICAgICAgZGVzdGluYXRpb24sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgIC4uLmhlYWRlcnMsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBzZW5kaW5nIG1lc3NhZ2U6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFN1YnNjcmliZSBjaGFubmVsXHJcbiAgY2xpZW50LnN1YnNjcmliZVRvQ2hhbm5lbCA9IChkZXN0aW5hdGlvbiwgY2FsbGJhY2ssIGhlYWRlcnMgPSB7fSkgPT4ge1xyXG4gICAgaWYgKCFjbGllbnQuY29ubmVjdGVkKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgQ2xpZW50IG5vdCBjb25uZWN0ZWQuIENhbm5vdCBzdWJzY3JpYmUuXCIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGllbnQuc3Vic2NyaWJlKGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgaGVhZGVycyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVjb25uZWN0IHdpdGggcmVmcmVzaGVkIHRva2VuXHJcbiAgYXN5bmMgZnVuY3Rpb24gcmVjb25uZWN0V2l0aE5ld1Rva2VuKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB3YWl0Rm9yVmFsaWRUb2tlbldpdGhGYWxsYmFjaygpO1xyXG4gICAgICBjbGllbnQuY29ubmVjdEhlYWRlcnMgPSB7XHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIgKyB0b2tlbixcclxuICAgICAgfTtcclxuICAgICAgY2xpZW50LmRlYWN0aXZhdGUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICBjbGllbnQuYWN0aXZhdGUoKTsgLy8gcmVjb25uZWN0XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW4gYW5kIHJlY29ubmVjdDpcIiwgZXJyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjbGllbnQ7XHJcbn1cclxuXHJcbi8vIEJ14buZYyBs4bqleSB0b2tlbiBo4bujcCBs4buHIC0gc+G7rSBk4bulbmcgYXhpb3MgaW50ZXJjZXB0b3IgxJHhu4MgcmVmcmVzaFxyXG5hc3luYyBmdW5jdGlvbiBmb3JjZUdldFZhbGlkVG9rZW4obWF4UmV0cmllcyA9IDMpIHtcclxuICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgXHJcbiAgd2hpbGUgKHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGdldEF1dGhUb2tlbigpO1xyXG4gICAgICBcclxuICAgICAgLy8gTuG6v3UgY8OzIHRva2VuIHbDoCBjw7JuIGjhuqFuIHRow6wgcmV0dXJuXHJcbiAgICAgIGlmICh0b2tlbiAmJiBpc1Rva2VuVmFsaWQoKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFRva2VuIGlzIHZhbGlkXCIpO1xyXG4gICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gTuG6v3Uga2jDtG5nIGPDsyB0b2tlbiBob+G6t2MgaOG6v3QgaOG6oW4sIGJ14buZYyByZWZyZXNoIGLhurFuZyBjw6FjaCBn4buNaSBBUEkgcHJvdGVjdGVkXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFRyaWdnZXJpbmcgdG9rZW4gcmVmcmVzaCAoYXR0ZW1wdCAke3JldHJpZXMgKyAxfS8ke21heFJldHJpZXN9KWApO1xyXG4gICAgICBcclxuICAgICAgLy8gR+G7jWkgbeG7mXQgQVBJIHByb3RlY3RlZCDEkeG7gyB0cmlnZ2VyIHJlZnJlc2ggdG9rZW4gdHJvbmcgYXhpb3MgaW50ZXJjZXB0b3JcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBhcGkuZ2V0KCcvdjEvYXV0aC92YWxpZGF0ZScpOyAvLyBob+G6t2MgZW5kcG9pbnQgbsOgbyDEkcOzIHnDqnUgY+G6p3UgYXV0aFxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIE7hur91IGzhu5dpIDQwMSwgYXhpb3MgaW50ZXJjZXB0b3Igc+G6vSB04buxIMSR4buZbmcgcmVmcmVzaCB0b2tlblxyXG4gICAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBUb2tlbiByZWZyZXNoIHRyaWdnZXJlZCBieSA0MDEgcmVzcG9uc2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBLaeG7g20gdHJhIGzhuqFpIHRva2VuIHNhdSBraGkgYXhpb3MgaW50ZXJjZXB0b3IgeOG7rSBsw71cclxuICAgICAgY29uc3QgbmV3VG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcclxuICAgICAgaWYgKG5ld1Rva2VuICYmIGlzVG9rZW5WYWxpZCgpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgVG9rZW4gcmVmcmVzaGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgICAgICByZXR1cm4gbmV3VG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgdmFsaWQgdG9rZW4gYWZ0ZXIgcmVmcmVzaCBhdHRlbXB0XCIpO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHJpZXMrKztcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIFRva2VuIHJlZnJlc2ggYXR0ZW1wdCAke3JldHJpZXN9IGZhaWxlZDpgLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocmV0cmllcyA+PSBtYXhSZXRyaWVzKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBNYXggcmV0cmllcyByZWFjaGVkLiBTZXNzaW9uIG1heSBiZSBleHBpcmVkLlwiKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHZhbGlkIHRva2VuIGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeVxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCAqIHJldHJpZXMpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEFsdGVybmF0aXZlOiBT4butIGThu6VuZyBQcm9taXNlLnJhY2UgxJHhu4Mga+G6v3QgaOG7o3AgZXZlbnQtYmFzZWQgdsOgIHBvbGxpbmdcclxuZnVuY3Rpb24gd2FpdEZvclZhbGlkVG9rZW5XaXRoRmFsbGJhY2sodGltZW91dCA9IDMwMDApIHtcclxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcclxuICAgIC8vIEFwcHJvYWNoIDE6IENo4budIGV2ZW50IHThu6sgYXhpb3MgaW50ZXJjZXB0b3JcclxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcclxuICAgICAgaWYgKHRva2VuICYmIGlzVG9rZW5WYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodG9rZW4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uVG9rZW5SZWZyZXNoKChuZXdUb2tlbikgPT4ge1xyXG4gICAgICAgIGlmIChuZXdUb2tlbiAmJiBpc1Rva2VuVmFsaWQoKSkge1xyXG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgIHJlc29sdmUobmV3VG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBDbGVhbnVwIG7hur91IGtow7RuZyBjw7MgdG9rZW4gZXZlbnQgdHJvbmcgdGjhu51pIGdpYW4gdGltZW91dFxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUb2tlbiBldmVudCB0aW1lb3V0XCIpKTtcclxuICAgICAgfSwgdGltZW91dCk7XHJcbiAgICB9KSxcclxuICAgIFxyXG4gICAgLy8gQXBwcm9hY2ggMjogRm9yY2UgcmVmcmVzaCBuZ2F5IGzhuq1wIHThu6ljXHJcbiAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAvLyDEkOG7o2kgbeG7mXQgY2jDunQgxJHhu4MgZXZlbnQgY8OzIGPGoSBo4buZaSB44bqjeSByYSB0csaw4bubY1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XHJcbiAgICAgIHJldHVybiBmb3JjZUdldFZhbGlkVG9rZW4oKTtcclxuICAgIH0pKClcclxuICBdKTtcclxufSJdLCJuYW1lcyI6WyJTb2NrSlMiLCJDbGllbnQiLCJnZXRBdXRoVG9rZW4iLCJpc1Rva2VuVmFsaWQiLCJvblRva2VuUmVmcmVzaCIsImFwaSIsImNyZWF0ZVN0b21wQ2xpZW50Iiwib25Db25uZWN0IiwiY2xpZW50Iiwid2ViU29ja2V0RmFjdG9yeSIsImNvbm5lY3RIZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImRlYnVnIiwic3RyIiwiY29uc29sZSIsImxvZyIsInJlY29ubmVjdERlbGF5IiwiZnJhbWUiLCJvbkRpc2Nvbm5lY3QiLCJ3YXJuIiwib25XZWJTb2NrZXRDbG9zZSIsIm9uV2ViU29ja2V0RXJyb3IiLCJldmVudCIsImVycm9yIiwib25TdG9tcEVycm9yIiwiaGVhZGVycyIsImJvZHkiLCJpbmNsdWRlcyIsInJlY29ubmVjdFdpdGhOZXdUb2tlbiIsImJlZm9yZUNvbm5lY3QiLCJ0b2tlbiIsIndhaXRGb3JWYWxpZFRva2VuV2l0aEZhbGxiYWNrIiwic2VuZE1lc3NhZ2UiLCJkZXN0aW5hdGlvbiIsIm1lc3NhZ2UiLCJjb25uZWN0ZWQiLCJwdWJsaXNoIiwiSlNPTiIsInN0cmluZ2lmeSIsInN1YnNjcmliZVRvQ2hhbm5lbCIsImNhbGxiYWNrIiwic3Vic2NyaWJlIiwiZGVhY3RpdmF0ZSIsInRoZW4iLCJhY3RpdmF0ZSIsImVyciIsImZvcmNlR2V0VmFsaWRUb2tlbiIsIm1heFJldHJpZXMiLCJyZXRyaWVzIiwiZ2V0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJuZXdUb2tlbiIsIkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidGltZW91dCIsInJhY2UiLCJyZWplY3QiLCJ1bnN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/socket.js\n"));

/***/ })

});